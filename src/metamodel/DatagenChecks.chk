import datagen;
import rdbmdl;

extension org::openarchitectureware::util::stdlib::naming;
extension template::DatagenExtensions; 

context DBAccessModel ERROR "codice prodotto mancante" :
	!isNullOrEmpty(codProdotto);
	
context DBAccessModel ERROR "codice componente mancante" :
	!isNullOrEmpty(codComponente);

context DataAccessObject ERROR "Occorre specificare il nome del DAO:" :
	!isNullOrEmpty(name);

context DataAccessObject if (pkGenerator != null && pkGenerator.metaType == SequencePKGenerator) 
ERROR "Il SequencePKGenerator è utilizzabile solo con PK di 1 sola colonna":
	mainTable.primaryKey.includedColumns.size == 1;
	
/// verifiche sui finder
context DataAccessObject WARNING "il dao:"+this.name+" non definisce i finder base (findByPK e findAll)" :
	finders != null && finders.finders.select(f| (f.metaType==FindAll || f.metaType==FindByPK)).size==2;

context DataAccessObject WARNING "il dao: "+this.name+" non definisce nessun inserter" :
	inserter != null;

context DataAccessObject WARNING "il dao: "+this.name+" non definisce nessun updater di base (UpdateRow)" :
	updaters != null && updaters.updaters.select(f| (f.metaType==UpdateRow)).size==1;

context DataAccessObject ERROR "I nomi dei metodi contenuti nel dao : "+this.name+" devono essere univoci" :
	areAllDaoMethodsNamesUnivocal(inserter,finders,updaters,deleters);
	
context Finder if (metaType != FindByPK && metaType != FindAll && metaType != QBEFinder) ERROR "E' necessario specificare il nome dei finder (esclusi il findByPK, findAll, QBEFinder)"+((DataAccessObject)(this.eContainer.eContainer)).name:
	!isNullOrEmpty(name);
	
context Updater if (metaType != UpdateRow) ERROR "E' necessario specificare il nome degli updater (escluso l'UpdateRow)"+((DataAccessObject)(this.eContainer.eContainer)).name:
	!isNullOrEmpty(name);

context CustomFinder ERROR "E' necessario specificare la classe del parametro di filtro (full qualified name, oppure "+
" '$dto' per utilizzare la classe del DTO associata al DAO, o '$dto[]' per utilizzare una"+
"lista di oggetti DTO):"+loc() :
	this.filterClassFQN!=null && this.filterClassFQN != "";

context CustomFinder if (customSelect) ERROR "La clausola distinct è incompatibile con l'attributo 'customSelect'"+loc() :
	this.distinct.size==0;

context Deleter if (metaType != DeleteByPK) ERROR "E' necessario specificare il nome dei deleter (escluso il DeleteByPK)"+((DataAccessObject)(this.eContainer.eContainer)).name:
	!isNullOrEmpty(name);
	
context MultiResFinder if (!isNullOrEmpty(distinct) && orderSpecs!=null && !isNullOrEmpty(orderSpecs.specs)) ERROR "Se la ricerca per distinct è abilitata, tutte le eventuali colonne presenti nella OrderSpecs devono essere presenti anche in distinct. "+((DataAccessObject)(this.eContainer.eContainer)).name:
	areDistinctAndOrderByClauseConsistent(distinct,orderSpecs.specs);

context LookupResolver ERROR "I lookup-resolver devono specificare la FK risolta:"+loc() :
	this.foreignKey != null;
	
context LookupResolver ERROR "I lookup-resolver devono specificare il DAO supplier:"+loc() :
	this.supplierDAO != null;

context LookupResolver if supplierDAO!=null && foreignKey != null 
	ERROR "Il DAO "+supplierDAO.name+", specificato come supplier, è relativo a una "+
		  "tabella differente da quella specificata nella FK da risolvere ("+foreignKey.name+")" :
		supplierDAO.mainTable!=null && foreignKey.includedColumns.size>0 
		&& supplierDAO.mainTable == ((Table)(foreignKey.includedColumns.first().eContainer));
		
		
//// limitazioni temporanee
context QBEFinder ERROR "Il QBEFinder non può funzionare in modalità DISTINCT" :
this.distinct.size==0;

//context QBEFinder ERROR "Il QBEFinder non supporta la clausola ORDER BY" :
//this.orderSpecs==null;

// check sulla cache: cache impostata (ALMOST_STABLE_DATA) ma TTL minore zero
context DataAccessObject if(this.cacheability==CacheabilityTypes::ALMOST_STABLE_DATA && this.cacheTTLminutes<0) ERROR "E' stato impostato un TTL minore di zero per il dao: "+loc()+ " , dato non consistente":
false;

// check sulla cache: cache non impostata (HIGHLY_VARIABLE_DATA) ma TTL diverso da zero
context DataAccessObject if(this.cacheability==CacheabilityTypes::HIGHLY_VARIABLE_DATA) WARNING "E' stato impostato un TTL diverso da zero per il dao: "+loc()+ " , ma la cache non e' abilitata (HIGHLY_VARIABLE_DATA)":
!(this.cacheTTLminutes != 0);

// check sulla cache: cache impostata ma TTL zero: usare il default di 24 ore!!!
context DataAccessObject if(this.cacheability==CacheabilityTypes::ALMOST_STABLE_DATA)  WARNING "E' stato impostata la cache per il dao " +loc()+" , con TTL pari zero, pertanto si utilizza il default di 24hr":
!(this.cacheTTLminutes == 0);





