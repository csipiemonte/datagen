«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT ecore»
«IMPORT datagen»
«IMPORT rdbmdl»
«IMPORT rdbmdl::constraints»
«IMPORT rdbmdl::datatypes»
«IMPORT rdbmdl::view»

«EXTENSION template::DatagenExtensions»

«DEFINE daoFiles FOR DBAccessModel»
«EXPAND daoFiles(this) FOREACH daopkgs»
«EXPAND utilFiles FOR this»
«ENDDEFINE»

«DEFINE daoFiles (DBAccessModel model) FOR DaoPackage»
«EXPAND commonDaoFiles(model) FOR this»
«EXPAND daoFiles(model) FOREACH dao»
«ENDDEFINE»

«DEFINE daoFiles(DBAccessModel model) FOR DataAccessObject»
«EXPAND daoFile(model) FOR this»
«EXPAND daoImplFile(model) FOR this»
«EXPAND daoExceptionFile(model) FOR this»
«ENDDEFINE»

«DEFINE daoExceptionFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDaoExcFullPath(this, model)»package «pkgPackage».exceptions;

/**
 *
 * @generated
 */
public class «getDaoExcClassName()» extends DaoException
{
	/** 
	 * @param message
	 * @generated
	 */
	public «getDaoExcClassName()»(String message)
	{
		super(message);
	}

	/**
	 * @param message
	 * @param cause
	 * @generated
	 */
	public «getDaoExcClassName()»(String message, Throwable cause)
	{
		super(message, cause);
	}

}
«ENDFILE»
«ENDLET»
«ENDDEFINE»

«DEFINE daoFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDaoFullPath(this, model)»package «pkgPackage».dao;

import «pkgPackage».dao.*;
import «pkgPackage».dto.*;
import «pkgPackage».qbe.*;
import «pkgPackage».metadata.*;
import «pkgPackage».exceptions.*;
import «getDALayerBasePkg(model)».util.*;
import «getDALayerBasePkg(model)».qbe.*;
import java.util.*;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * @generated
 */
public interface «getDaoClassName()» {
	«IF inserter != null-»
		«EXPAND insertMethod(model, false) FOR this-»
	«ENDIF-»	
	
	«EXPAND template::datagen::dao::updaters::updaters(model, false) FOR this-»
	
	«EXPAND template::datagen::dao::deleters::deleters(model, false) FOR this-»
	
	«EXPAND mapRowMethods(model, false) FOR this-»
	
	«EXPAND template::datagen::dao::finders::finders(model, false) FOR this-»
}
«ENDFILE-»
«ENDLET-»
«ENDDEFINE»

«DEFINE daoImplFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDaoImplFullPath(this, model)»package «pkgPackage».dao.impl;

import «pkgPackage».dao.*;
import «pkgPackage».dto.*;
import «pkgPackage».qbe.*;
import «pkgPackage».metadata.*;
import «pkgPackage».exceptions.*;
import «getDALayerBasePkg(model)».util.*;
import «getDALayerBasePkg(model)».qbe.*;
import java.util.*;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.ParameterizedRowMapper;
import it.csi.util.performance.StopWatch;
import org.apache.log4j.Logger;
import java.util.Map;
import java.util.TreeMap;



«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getDaoImplFQN(this,model)+"extraimport")»
// aggiungere qui eventuali import custom. 
«ENDPROTECT»

/**
 * @generated
 */
public class «getDaoImplClassName()» extends AbstractDAO implements ParameterizedRowMapper<«getDtoClassName()»>, «getDaoClassName()»
{
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE);
	/**
	 * @generated
	 */
	protected NamedParameterJdbcTemplate jdbcTemplate;
	
	/**
	 * @generated
	 */
	public void setJdbcTemplate(NamedParameterJdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}
	
	«IF this.cacheability==CacheabilityTypes::ALMOST_STABLE_DATA»
	/**
	 * @generated
	 */
	 protected SimpleCache cache;
	
	
	public SimpleCache getCache() {
		return cache;
	}

	public void setCache(SimpleCache cache) {
		this.cache = cache;
	}
	«ENDIF»
	
	

	«IF inserter != null-»
		«EXPAND insertMethod(model, true) FOR this»
	«ENDIF»
	
	«EXPAND template::datagen::dao::updaters::updaters(model, true) FOR this»
	
	«EXPAND template::datagen::dao::deleters::deleters(model, true) FOR this»
	
	«EXPAND mapRowMethods(model, true) FOR this»

	«IF finders!=null-»
    	«EXPAND rowMapperObject(this) FOREACH this.finders.finders»
    «ENDIF-»

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 * @generated
	 */
	public String getTableName()
	{
		return "«mainTable.name»";
	}

	«EXPAND template::datagen::dao::finders::finders(model, true) FOR this»
	
	«EXPAND rowMapperInnerClass FOR this»
	
	«EXPAND supplierDaoSpringProperties FOR this»
}

«ENDFILE-»
«ENDLET-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR Finder-»
«ERROR "rowMapperObject: tipo di finder non gestito:"+this»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR FindAll-»
	«EXPAND rowMapperObject_internal(dao, this.distinct) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR FindByPK-»
	«EXPAND rowMapperObject_internal(dao, null) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR CustomFinder-»
	«EXPAND rowMapperObject_internal(dao, this.distinct) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR QBEFinder-»
	«EXPAND rowMapperObject_internal(dao, this.distinct) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject_internal(DataAccessObject dao, List[Column] distinctColumns) FOR Finder-»
	«REM»se si tratta di un custom finder con qDef si deve istanziare la classe RowMapper passando come argomento il dto specificatamente creato«ENDREM»
	«IF this.metaType==CustomFinder && ((CustomFinder)this).queryDefinition!=null»
		protected «getDaoClassName(dao)»RowMapper «name»RowMapper = new «getDaoClassName(dao)»RowMapper(
		null,«getDtoCustomQdefClassName(dao,(CustomFinder)this)».class);
	«ELSE»
		protected «getDaoClassName(dao)»RowMapper «name»RowMapper = new «getDaoClassName(dao)»RowMapper(
	«IF distinctColumns == null || distinctColumns.size==0-»null
	«ELSE-»new String[]{«FOREACH distinctColumns AS currCol SEPARATOR ","»"«currCol.name»"«ENDFOREACH»}
	«ENDIF-», «getDtoClassName(dao)».class
	);
	«ENDIF»
«ENDDEFINE»


«DEFINE rowMapperInnerClass FOR DataAccessObject»
	/// flexible row mapper. 
	public class «getDaoClassName()»RowMapper implements org.springframework.jdbc.core.RowMapper {
		
		private java.util.HashMap<String,String> columnsToReadMap = new java.util.HashMap<String, String>();
		private boolean mapAllColumns = true;
		private Class dtoClass;
		
		/**
		 * @param columnsToRead elenco delle colonne da includere nel mapping (per query
		 *        incomplete, esempio distinct, custom select...)
		 */
		public «getDaoClassName()»RowMapper(String[] columnsToRead, Class dtoClass) {
			if (columnsToRead != null) {
				mapAllColumns = false;
				for (int i=0; i<columnsToRead.length; i++)
					columnsToReadMap.put(columnsToRead[i], columnsToRead[i]);
			}
			this.dtoClass=dtoClass;
		}
		
		/**
		 * Method 'mapRow'
		 * 
		 * @param rs
		 * @param row
		 * @throws SQLException
		 * @return «getDtoClassName()»
		 * @generated
		 */
		public Object mapRow(ResultSet rs, int row) throws SQLException
		{
			«REM»comment«getDtoClassName()» dto = new «getDtoClassName()»();
			dto = mapRow_internal(dto, rs, row);
			return dto;«ENDREM»
			Object dto = null;
			try {
				dto = dtoClass.newInstance();
			} catch (InstantiationException e) {
				e.printStackTrace();
				throw new RuntimeException("Impossibile istanziare la classe " + dto.getClass().getCanonicalName()+" ,"+e.getCause());
			} catch (IllegalAccessException e) {
				e.printStackTrace();
				throw new RuntimeException("Impossibile accedere alla classe " + dto.getClass().getCanonicalName()+" ,"+e.getCause());
			}
			
			if(dto instanceof «getDtoClassName()»){
				return mapRow_internal((«getDtoClassName()»)dto, rs, row);
			}
			
			«REM»espando il mapping per i custom finder per tutti i dto specifici definiti all'interno del dao con Qdef«ENDREM»
			«LET this.finders.finders.typeSelect(CustomFinder).select(f|f.queryDefinition!=null) AS customJoinFinders»
				«IF customJoinFinders!=null && customJoinFinders.size>0»
					«EXPAND CustomFinderQdefMapping(this) FOREACH customJoinFinders »
				«ENDIF»
			«ENDLET»
			
			return dto;
		}
			
		 
		public «getDtoClassName()» mapRow_internal(
			«getDtoClassName()» objectToFill, 
			ResultSet rs, 
			int row) throws SQLException
		
		{	
			«getDtoClassName()» dto = objectToFill;
			«FOREACH mainTable.columns AS currCol ITERATOR i»
			«REM»per ogni colonna della tabella verifico se e' una FK associata al resolver, «ENDREM»
			«IF currCol.isForeignKey!=null && currCol.isForeignKey && this.lookupResolvers != null && this.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.contains(currCol)).size >0-»
			
			«ELSE»
			
			if (mapAllColumns || columnsToReadMap.get("«currCol.name»") != null)
				dto.set«javaPropertyNameFromColumn(currCol).toFirstUpper()-»(
			«IF !isBlobOrClob(currCol)-»
				«getValueFromRSByColName(currCol)-»
			«ELSE-»
				«getValueFromRS(currCol, i.counter1)»
			«ENDIF-»			
				);
			«ENDIF-»
			«ENDFOREACH-»
			
			
			«REM»expand sui resolvers, se ci sono«ENDREM»
			«IF this.lookupResolvers!=null && this.lookupResolvers.resolvers.size >0-»
				«EXPAND lookupResolverRowMapping FOREACH this.lookupResolvers.resolvers-»
			«ENDIF»
			return dto;
		}
		
		
		«LET this.finders.finders.typeSelect(CustomFinder).select(f|f.queryDefinition!=null) AS customJoinFinders»
				«IF customJoinFinders!=null && customJoinFinders.size>0»
					«EXPAND mapRowInternalQDef(this) FOREACH customJoinFinders »
				«ENDIF»
			«ENDLET»
		
	}
	
«ENDDEFINE»


«DEFINE mapRowInternalQDef(DataAccessObject dao) FOR CustomFinder»
	
	/**
	 * Method 'mapRow_internal'
	 * 
	 * @param rs
	 * @param row
	 * @throws SQLException
	 * @return «getDtoCustomQdefClassName(dao,this)»
	 * @generated
	 */

	public «getDtoCustomQdefClassName(dao,this)» mapRow_internal(
			«getDtoCustomQdefClassName(dao,this)» objectToFill, ResultSet rs, int row) throws SQLException
	{	
			«getDtoCustomQdefClassName(dao,this)» dto = objectToFill;
			«FOREACH this.queryDefinition.selectClause.columns AS currCol ITERATOR  i-»
				«EXPAND singleMapRowInternalQDef(i.counter1) FOR currCol-»
			«ENDFOREACH»
			return dto;
	}	 
«ENDDEFINE»


«DEFINE singleMapRowInternalQDef(Integer i) FOR QResultColumn»
	«ERROR "Non implementato"»
«ENDDEFINE»

«DEFINE singleMapRowInternalQDef(Integer i) FOR QTableColumn»
«REM»la logica di mapping deve seguire quella della creazione del DTO«ENDREM»
«IF isNullOrEmpty(this.alias)-»
	«IF isNullOrEmpty(this.qtable.aliasName)»
		if (mapAllColumns || columnsToReadMap.get("«this.column.name»") != null)
			dto.set«javaPropertyNameFromColumn(this.column).toFirstUpper()»(«IF !isBlobOrClob(this.column)-»
				«getValueFromRSByColName(this.column)-»
		«ELSE-»
			«getValueFromRS(this.column,i)-»
		«ENDIF-»			
		);	
	«ELSE-»
		if (mapAllColumns || columnsToReadMap.get("«this.column.name»") != null)
			dto.set«this.qtable.aliasName.toFirstUpper()»«javaPropertyNameFromColumn(this.column).toFirstUpper()»(«IF !isBlobOrClob(this.column)-»
			«getValueFromRSByColName(this.column)»
		«ELSE-»
			«getValueFromRS(this.column,i)»
		«ENDIF-»			
		);	
	«ENDIF-»
«ELSE-»
		if (mapAllColumns || columnsToReadMap.get("«this.alias.toFirstUpper()»") != null)
			dto.set«this.alias.toFirstUpper()»(«IF !isBlobOrClob(this.column)-»
				«getValueFromRSByColName(this.column)-»
		«ELSE-»
				«getValueFromRS(this.column,i)-»
		«ENDIF-»			
		);	
«ENDIF»
«ENDDEFINE»


«DEFINE columnNameList(boolean useDistinct) FOR List[TableColumn]-»
«IF useDistinct-»DISTINCT «ENDIF-»«FOREACH this AS currCol SEPARATOR ","-»«((TableColumn)currCol).name-»«ENDFOREACH-»
«ENDDEFINE»

«DEFINE distinctColumnsIfNecessary FOR List[TableColumn]-»
«IF this!=null && !this.isEmpty-»new String[]{«FOREACH this AS currCol SEPARATOR ","-»"«((TableColumn)currCol).name-»"«ENDFOREACH-»}«ENDIF-»
«ENDDEFINE»


«DEFINE columnNameList FOR List[TableColumn]-»
	«EXPAND columnNameList(false) FOR this-»
«ENDDEFINE»

«DEFINE setColumnSetValuePlaceholderList(DataAccessObject dao) FOR List[TableColumn]-»
SET «FOREACH this.select(c|!dao.mainTable.primaryKey.includedColumns.contains(c)) AS currCol SEPARATOR ","-»«((TableColumn)currCol).name» = :«((TableColumn)currCol).name-» «ENDFOREACH-»
«ENDDEFINE»

«DEFINE setColumnEqPlaceholderList(String separator) FOR List[TableColumn]-»
«FOREACH this AS currCol SEPARATOR separator-»«((TableColumn)currCol).name» = :«((TableColumn)currCol).name» «ENDFOREACH-»
«ENDDEFINE»

«DEFINE paramPlaceholderList FOR List[TableColumn]-»
«FOREACH this AS currCol SEPARATOR ","-» :«((TableColumn)currCol).name» «ENDFOREACH-»
«ENDDEFINE»

«DEFINE paramValorizationList(String dtoVarName, DataAccessObject dao) FOR List[TableColumn]-»
«FOREACH this AS currCol-»
«REM»se abbiamo una FK definita sulla colonna i-esima e un resolver associato ad essa, dobbiamo recuperare la property dal corrispondente oggetto risolto e non come usuale!!!«ENDREM»
	«IF currCol.isForeignKey!=null && currCol.isForeignKey && dao.lookupResolvers != null && dao.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.contains(currCol)).size >0-»
	«REM»do nothing...il dato viene trattato in seguito«ENDREM»
	«ELSE»	
	params.addValue("«((TableColumn)currCol).name»", «dtoVarName».get«javaPropertyNameFromColumn(currCol).toFirstUpper()»(), java.sql.Types.«currCol.type.type» );	
	«ENDIF»
«ENDFOREACH-»
«ENDDEFINE»

«DEFINE paramValorizationList(String dtoVarName, PKGenerator pkgen) FOR List[TableColumn]-»
«ERROR "valorizzazione parametri non gestita per DAO con PKGenerator di tipo "+pkgen.metaType»
«ENDDEFINE»

«DEFINE paramValorizationList(String dtoVarName, SequencePKGenerator pkgen) FOR List[TableColumn]-»
«LET (DataAccessObject)(pkgen.eContainer) AS dao-»
«LET dao.mainTable.primaryKey.includedColumns.first() AS pkCol-»
«FOREACH this AS currCol-»
	params.addValue("«((TableColumn)currCol).name»", «currCol==pkCol?" newKey ":dtoVarName+".get"+javaPropertyNameFromColumn(currCol).toFirstUpper()+"()"» , java.sql.Types.«currCol.type.type» );
«ENDFOREACH-»
«ENDLET-»
«ENDLET-»
«ENDDEFINE»

«DEFINE orderByClause FOR OrderSpecs»	
  «IF this!=null-»sql.append(" ORDER BY «FOREACH this.specs AS currSpec SEPARATOR ','-»«currSpec.column.name-»«IF currSpec.ascending-» ASC«ELSE-» DESC«ENDIF-»«ENDFOREACH-»");«ENDIF-»		
«ENDDEFINE»


«DEFINE incrementerUse FOR TableColumn-»
«IF type.type == PrimitiveTypeCodes::VARCHAR-»
	«javaPropertyTypeFromColumn()» newKey = incrementer.nextStringValue();
«ELSEIF (isNonDecimalNumber(this.type))-»
	«javaPropertyTypeFromColumn()» newKey = new «javaPropertyTypeFromColumn()»(incrementer.«getIncrementerNextValMethod()»);
«ELSE»
	«ERROR "impossibile usare incrementer per il tipo di colonna "+type.type+","+type.size+","+type.decimalDigits»
«ENDIF-»
		
«ENDDEFINE»

«DEFINE insertMethod(DBAccessModel model, boolean body) FOR DataAccessObject»
	/**
	 * Method 'insert'
	 * 
	 * @param dto
	 * @return «getPkClassName()»
	 * @generated
	 */
	«IF this.mainTable.primaryKey != null»
	public «getPkClassName()» insert(«getDtoClassName()» dto)
	«ELSE»
	public void insert(«getDtoClassName()» dto)
	«ENDIF»	
	«IF body-»
	{
		«IF mainTable.primaryKey!=null && pkGenerator!=null-»
		«EXPAND incrementerUse FOR this.mainTable.primaryKey.includedColumns.first()»
		«ENDIF-»
		final String sql = "INSERT INTO " + getTableName() + " ( «EXPAND columnNameList FOR this.mainTable.columns-» ) VALUES ( «EXPAND paramPlaceholderList FOR this.mainTable.columns-» )";
		
		MapSqlParameterSource params = new MapSqlParameterSource();
		«IF pkGenerator!=null-»
			«EXPAND paramValorizationList("dto",pkGenerator) FOR this.mainTable.columns-»
		«ELSE»
			«REM»nel seguente template si salteranno le colonne con lookup«ENDREM»
			«EXPAND paramValorizationList("dto",this) FOR this.mainTable.columns-»
			«REM»comment«ENDREM»
			«IF this.lookupResolvers!=null && this.lookupResolvers.resolvers.size>0-»
				«EXPAND lookedUpParamValorizationList("dto", this.mainTable.columns) FOR  this»
			«ENDIF»
		«ENDIF-»
		StopWatch stopWatch = new StopWatch(Constants.APPLICATION_CODE);
		try {
			stopWatch.start();
			jdbcTemplate.update(sql.toString(), params);
		} catch (RuntimeException ex) {
			log.error("[«getDaoImplClassName()»::insert] esecuzione query",ex);
			throw ex;
		} finally {
			stopWatch.dumpElapsed("«getDaoImplClassName()»", "insert","esecuzione query", sql);
			log.debug("[«getDaoImplClassName()»::insert] END");
		}
		
		«IF this.mainTable.primaryKey != null»
		«IF pkGenerator!=null-»
		«REM»se chiave multipla non funziona!!«ENDREM»
		«EXPAND fillPKFields("dto", "newKey") FOREACH this.mainTable.primaryKey.includedColumns-»
		«ENDIF-»
		return dto.createPk();
		«ENDIF»	
		
	}
	«ELSE-»
	;
	«ENDIF-»
	
«ENDDEFINE»

«DEFINE fillPKFields(String dtoVarName, String keyValVarName) FOR Column»
		«dtoVarName».set«javaPropertyNameFromColumn((TableColumn)this).toFirstUpper()»(«keyValVarName»);
«ENDDEFINE»

«DEFINE mapRowMethods(DBAccessModel model, boolean body) FOR DataAccessObject»
	/**
	 * Method 'mapRow'
	 * 
	 * @param rs
	 * @param row
	 * @throws SQLException
	 * @return «getDtoClassName()»
	 * @generated
	 */
	public «getDtoClassName()» mapRow(ResultSet rs, int row) throws SQLException
	«IF body-»
	{
		«getDtoClassName()» dto = new «getDtoClassName()»();
		dto = mapRow_internal(dto, rs, row);
		return dto;
	}
	«ELSE-»
	;
	«ENDIF-»
	
	
	/**
	 * Method 'mapRow_internal'
	 * 
	 * @param rs
	 * @param row
	 * @throws SQLException
	 * @return «getDtoClassName()»
	 * @generated
	 */
	public «getDtoClassName()» mapRow_internal(
		«getDtoClassName()» objectToFill, 
		ResultSet rs, 
		int row) throws SQLException
	«IF body-»
	{	
		«getDtoClassName()» dto = objectToFill;
		
		«getDaoClassName().toFirstUpper()»RowMapper «getDaoClassName().toFirstLower()»RowMapper = new «getDaoClassName().toFirstUpper()»RowMapper(null,«getDtoClassName()».class);
		
		«REM»«FOREACH mainTable.columns AS currCol ITERATOR i»
			«IF currCol.isForeignKey!=null && currCol.isForeignKey && this.lookupResolvers != null && this.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.contains(currCol)).size >0-»
			
			«ELSE»
		dto.set«javaPropertyNameFromColumn(currCol).toFirstUpper()»(
		«IF !isBlobOrClob(currCol)-»
			«getValueFromRSByColName(currCol)»
		«ELSE-»
			«getValueFromRS(currCol, i.counter1)»
		«ENDIF-»			
			);
			«ENDIF»
		«ENDFOREACH»
		«ENDREM»
		
		return «getDaoClassName().toFirstLower()»RowMapper.mapRow_internal(objectToFill, rs, row);
	}
	«ELSE-»
	;
	«ENDIF-»
	
	
«ENDDEFINE»


«DEFINE commonDaoFiles(DBAccessModel model) FOR DaoPackage»
«FILE getPkgDir(this, model)+"/dao/impl/AbstractDAO.java"»package «getPkgPackage(this, model)».dao.impl;

import java.io.*;
import java.sql.*;

import org.springframework.jdbc.support.incrementer.DataFieldMaxValueIncrementer;


/**
 * Base class for Oracle DAO classes.
 *
 * @generated
 */
public abstract class AbstractDAO
{
	/**
	 * @generated
	 */
	protected DataFieldMaxValueIncrementer incrementer;
	
	/**
	 * @generated
	 */   
	public void setIncrementer(DataFieldMaxValueIncrementer incrementer) {
		this.incrementer = incrementer;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 * @generated
	 */
	public abstract String getTableName();
	
	
	«EXPAND abstractDAODBMSSpecificCode FOR this»
	
}
«ENDFILE»

«FILE getPkgDir(this, model)+"/exceptions/DaoException.java"»package «getPkgPackage(this, model)».exceptions;

/**
 * @generated
 */
public class DaoException extends RuntimeException
{
	/**
	 * @generated
	 */
	protected Throwable throwable;

	/**
	 * Method 'DaoException'
	 * 
	 * @param message
	 * @generated
	 */
	public DaoException(String message)
	{
		super(message);
	}

	/**
	 * Method 'DaoException'
	 * 
	 * @param message
	 * @param throwable
	 * @generated
	 */
	public DaoException(String message, Throwable throwable)
	{
		super(message);
		this.throwable = throwable;
	}

	/**
	 * Method 'getCause'
	 * 
	 * @return Throwable
	 * @generated
	 */
	public Throwable getCause()
	{
		return throwable;
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE abstractDAODBMSSpecificCode FOR DaoPackage»
«ERROR "abstractDAODBMSSpecificCode: aop non risolta"»
«ENDDEFINE»

«REM»gestire l'univocità della regione protetta per la compatibilità con servicegen«ENDREM»
«DEFINE utilFiles FOR DBAccessModel»
«FILE getDALayerBaseDir(this)+"/util/Constants.java"»package «getDALayerBasePkg(this)».util;
/**
* @generated
*/
public final class Constants {
	/**
	 * identificativo dell'applicativo.
	 */
	public static final String APPLICATION_CODE = "«this.codComponente»";
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("DaoConstants")»
	
	«ENDPROTECT»
}
«ENDFILE»

«FILE getDALayerBaseDir(this)+"/util/NamedParameterJdbcTemplateWithQueryDebug.java"»package «getDALayerBasePkg(this)».util; 
import java.util.Date;
import java.util.List;

import javax.sql.DataSource;

import org.apache.log4j.Logger;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

public class NamedParameterJdbcTemplateWithQueryDebug
		extends
			NamedParameterJdbcTemplate {

	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE);

	private static String PLACEHOLDER = ":";

	private static String[] terminatoriParametro = new String[]{" ","=",")","|","(",">","<","+","-","*","/"}; 
	
	public NamedParameterJdbcTemplateWithQueryDebug(DataSource dataSource) {
		super(dataSource);
	}

	public NamedParameterJdbcTemplateWithQueryDebug(
			JdbcOperations classicJdbcTemplate) {
		super(classicJdbcTemplate);
	}

	@Override
	public int update(String sql, SqlParameterSource paramSource)
			throws DataAccessException {
		try {
			logSql(sql, paramSource);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return super.update(sql, paramSource);
	}

	@Override
	public List query(String sql, SqlParameterSource paramSource,
			RowMapper rowMapper) throws DataAccessException {
		try {
			logSql(sql, paramSource);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return super.query(sql, paramSource, rowMapper);
	}

	/**
	 * stampa su log la query con i valori dei parametri impostati al posto dei placeholder
	 * 
	 * @param sql query con i placeholder 
	 * @param paramSource  mappa contenente i parametri e loro valori
	 */
	private void logSql(String sql, SqlParameterSource paramSource) {
		if(log.isDebugEnabled()){
			sql = buildSqlWithParameters(sql, paramSource);
		}
		log.debug(sql);
	}

	/**
	 * 
	 * Restituisce una query con i valori impostati al posto dei placeholder (:nomeparametro)
	 * 
	 * @param sql query con i placeholder 
	 * @param paramSource  mappa contenente i parametri e loro valori
	 * @return
	 */
	private String buildSqlWithParameters(String sql,
			SqlParameterSource paramSource) {
		String[] parametriQuery = sql.split(PLACEHOLDER);
		for (String parametro : parametriQuery) {
			parametro = getParametroUtile(parametro);
			if (paramSource.hasValue(parametro)) {
				sql = sql.replaceAll(PLACEHOLDER + parametro, getValue(paramSource, parametro));
			}
		}
		return sql;
	}

	/**
	 * Cerca all'interno di una parte di query la minore porzione di stringa utile per essere considerata
	 * come parametro
	 *  
	 * @param parametro  pezzo di query ottenuta da una istruzione split con il carattere ':' come separatore 
	 * @return la minore parola utile utilizzabile come parametro della query
	 */
	private String getParametroUtile(String parametro) {
		int posizioneTerminatoreAttuale = 0;
		for (int i = 0; i < terminatoriParametro.length; i++) {
			posizioneTerminatoreAttuale = parametro.indexOf(terminatoriParametro[i]); 
			if(posizioneTerminatoreAttuale > 0)
			{
				parametro = parametro.substring(0,posizioneTerminatoreAttuale);
			}
		}
		return parametro;
	}

	/**
	 * restituisce una rappresentazione in formato stringa di un parametro con placeholder
	 * nella query prelevando il valore dalla Map
	 * @param paramSource mappa contenente i parametri e ralativi valori
	 * @param parametro nome del parametro nella query
	 * @return
	 */
	private String getValue(SqlParameterSource paramSource, String parametro) {
		String resultValue = "null";
		Object paramValue = paramSource.getValue(parametro);

		if (paramValue != null) {
			if (paramValue instanceof String) {
				return "'" + ((String) paramValue).replaceAll("'", "''") + "'";
			} else if (paramValue instanceof Number) {
				resultValue = paramValue.toString();
			} else if (paramValue instanceof Date) {
				resultValue = parseDate((Date) paramValue);
			}
		}
		return resultValue;
	}

	/**
	 * Converte una data in un formato stringa utilizzabile nelle query per Oracle 
	 * @param date 
	 * @return  stringa rappresentante la data nel formato to_date(,DD/MM/YYYY HH24:MI:SS')
	 */
	private static String parseDate(java.util.Date date) {
		String retvalue = "";
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTime(date);
		retvalue = Integer.toString(cal.get(java.util.Calendar.DAY_OF_MONTH))
				+ "/";
		retvalue = retvalue
				+ Integer.toString(cal.get(java.util.Calendar.MONTH) + 1) + "/";
		retvalue = retvalue
				+ Integer.toString(cal.get(java.util.Calendar.YEAR)) + "-";
		retvalue = retvalue
				+ Integer.toString(cal.get(java.util.Calendar.HOUR_OF_DAY))
				+ ":";
		retvalue = retvalue
				+ Integer.toString(cal.get(java.util.Calendar.MINUTE)) + ":";
		retvalue = retvalue
				+ Integer.toString(cal.get(java.util.Calendar.SECOND));
		retvalue = "to_date('" + retvalue + "','DD/MM/YYYY HH24:MI:SS')";
		return retvalue;
	}

}

«ENDFILE»

«FILE getDALayerBaseDir(this)+"/util/SimpleCache.java"»package «getDALayerBasePkg(this)».util; 

import java.util.HashMap;
import java.util.Iterator;

import org.apache.log4j.Logger;

public class SimpleCache {
	
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE);
	
	HashMap<Object, CacheElement> map = new HashMap<Object, CacheElement>();
	int ttl_minutes = 0;
	boolean updateAccessTime = false;
	
	public SimpleCache(int ttl, boolean updateAccessTime){
		this.ttl_minutes=ttl;
		this.updateAccessTime=updateAccessTime;
	}
	
	//store del dato
	public void put(Object key, Object value){
		CacheElement el = new CacheElement();
		el.setLastAccess(System.currentTimeMillis());
		el.setValue(value);
		map.put(key, el);
	}
	
	//accesso al dato
	public Object get(Object key){
		CacheElement el = map.get(key);
		if (el != null){
			if ((System.currentTimeMillis() - el.getLastAccess())>(ttl_minutes*60000)){
				log.debug("elemento trovato ma scaduto... (impostato TTL pari a "+ttl_minutes+" minuti");
				map.remove(key);
				return null;
			}
		
		else{
				log.debug("elemento trovato");
				if(updateAccessTime){
					el.setLastAccess(System.currentTimeMillis());
				}
				map.put(key, el); // non servirebbe nemmeno, reference...
				Object val = el.getValue();
				return val;
			}
		}
		else {
			log.debug("elemento non trovato");
			return null;
		}
			
	}
	
	
	//per debug
	public void dumpCache(){
		Iterator<Object> it = map.keySet().iterator();
		while(it.hasNext()){
			Object currK = it.next();
			CacheElement el = map.get(currK);
			log.debug("key:"+currK+", val:"+el.getValue()+", lastAccess:"+el.getLastAccess());
		}
	}
}

«ENDFILE»

«FILE getDALayerBaseDir(this)+"/util/CacheElement.java"»package «getDALayerBasePkg(this)».util;

public class CacheElement {
	
		long lastAccess = 0;
		Object value = null;
		
		public long getLastAccess() {
			return lastAccess;
		}
		public void setLastAccess(long lastAccess) {
			this.lastAccess = lastAccess;
		}
		public Object getValue() {
			return value;
		}
		public void setValue(Object value) {
			this.value = value;
		}

}

«ENDFILE»

«ENDDEFINE»


«DEFINE lookupResolverRowMapping FOR LookupResolver»

	
	if (mapAllColumns ||«FOREACH this.foreignKey.includedColumns AS includedColumn SEPARATOR "&&"» columnsToReadMap.get(«getValueFromRSByColName(includedColumn)») != null «ENDFOREACH»){
		«this.supplierDAO.getDtoClassName()» «this.supplierDAO.getDtoClassName().toFirstLower()» = null;
				try {
					«this.supplierDAO.getDtoClassName().toFirstLower()»   = «this.supplierDAO.getDaoClassName().toFirstLower()».findByPrimaryKey(new «this.supplierDAO.getPkClassName()»(«FOREACH this.foreignKey.includedColumns AS includedColumn SEPARATOR ","» «getValueFromRSByColName(includedColumn)»«ENDFOREACH»));
				} catch («this.supplierDAO.getDaoExcClassName()» e) {
					log.error("Si e' verificato un errore nella chiamata al dao supplier: " +  «this.supplierDAO.getDaoClassName().toFirstLower()» + " : "+e);
					e.printStackTrace();
				}
		dto.set«getLookedUpPropertyName(this).toFirstUpper()»(«this.supplierDAO.getDtoClassName().toFirstLower()»);
	}


«ENDDEFINE»


«DEFINE supplierDaoSpringProperties FOR DataAccessObject»
	
	«IF this.lookupResolvers!=null && this.lookupResolvers.resolvers.size > 0»
		«FOREACH this.lookupResolvers.resolvers AS currResolver»
			private «getDaoClassName(currResolver.supplierDAO)» «getDaoClassName(currResolver.supplierDAO).toFirstLower()»;
			
			public «getDaoClassName(currResolver.supplierDAO)» get«getDaoClassName(currResolver.supplierDAO)»(){
				return «getDaoClassName(currResolver.supplierDAO).toFirstLower()»;
			}
			
			public void set«getDaoClassName(currResolver.supplierDAO)»(«getDaoClassName(currResolver.supplierDAO)» val){
				this.«getDaoClassName(currResolver.supplierDAO).toFirstLower()» = val;
			}
		«ENDFOREACH»
	«ELSE»
	«REM» do nothing«ENDREM»
	«ENDIF»

«ENDDEFINE»




«DEFINE lookedUpParamValorizationList(String dtoVarName, List[TableColumn] list) FOR DataAccessObject»

«FOREACH this.lookupResolvers.resolvers AS currResolver»
		«FOREACH currResolver.foreignKey.includedColumns AS cmpForeignKey ITERATOR i»
			«IF list.contains(cmpForeignKey)»
			«LET  (List[TableColumn])currResolver.foreignKey.referredUC.includedColumns AS pkCols» 
				params.addValue("«((TableColumn)currResolver.foreignKey.includedColumns.get(i.counter0)).name»",«dtoVarName».get«getLookedUpPropertyName(currResolver).toFirstUpper()»().get«javaPropertyNameFromColumn(pkCols.get(i.counter0)).toFirstUpper()»(), java.sql.Types.«((TableColumn)currResolver.foreignKey.includedColumns.get(i.counter0)).type.type» ); 
				«ENDLET»
			«ENDIF»
		«ENDFOREACH»		
«ENDFOREACH»

«ENDDEFINE»

«DEFINE CustomFinderQdefMapping(DataAccessObject dao) FOR CustomFinder-»
	if(dto instanceof «getDtoCustomQdefClassName(dao,this)»){
			return mapRow_internal((«getDtoCustomQdefClassName(dao,this)»)dto, rs, row);
	}
«ENDDEFINE»

