«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT ecore»
«IMPORT datagen»
«IMPORT rdbmdl»
«IMPORT rdbmdl::constraints»
«IMPORT rdbmdl::datatypes»
«IMPORT rdbmdl::view»

«EXTENSION template::DatagenExtensions»

«DEFINE daoFiles FOR DBAccessModel»
«EXPAND daoFiles(this) FOREACH daopkgs»
«EXPAND utilFiles FOR this»
«ENDDEFINE»

«DEFINE daoFiles (DBAccessModel model) FOR DaoPackage»
«EXPAND commonDaoFiles(model) FOR this»
«EXPAND daoFiles(model) FOREACH dao»
«ENDDEFINE»

«DEFINE daoFiles(DBAccessModel model) FOR DataAccessObject»
«EXPAND daoFile(model) FOR this»
«EXPAND daoImplFile(model) FOR this»
«EXPAND daoExceptionFile(model) FOR this»
«ENDDEFINE»

«DEFINE daoExceptionFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDaoExcFullPath(this, model)»package «pkgPackage».exceptions;

/**
 *
 * @generated
 */
public class «getDaoExcClassName()» extends DaoException
{
	/** 
	 * @param message
	 * @generated
	 */
	public «getDaoExcClassName()»(String message)
	{
		super(message);
	}

	/**
	 * @param message
	 * @param cause
	 * @generated
	 */
	public «getDaoExcClassName()»(String message, Throwable cause)
	{
		super(message, cause);
	}

}
«ENDFILE»
«ENDLET»
«ENDDEFINE»

«DEFINE daoFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDaoFullPath(this, model)»package «pkgPackage».dao;

import «pkgPackage».dao.*;
import «pkgPackage».dto.*;
import «pkgPackage».qbe.*;
import «pkgPackage».metadata.*;
import «pkgPackage».exceptions.*;
import «getDALayerBasePkg(model)».util.*;
import «getDALayerBasePkg(model)».qbe.*;
import java.util.*;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * @generated
 */
public interface «getDaoClassName()» {
	«IF inserter != null-»
		«EXPAND insertMethod(model, false) FOR this-»
	«ENDIF-»	
	
	«EXPAND template::datagen::dao::updaters::updaters(model, false) FOR this-»
	
	«EXPAND template::datagen::dao::deleters::deleters(model, false) FOR this-»
	
	«EXPAND mapRowMethods(model, false) FOR this-»
	
	«EXPAND template::datagen::dao::finders::finders(model, false) FOR this-»
}
«ENDFILE-»
«ENDLET-»
«ENDDEFINE»

«DEFINE daoImplFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDaoImplFullPath(this, model)»package «pkgPackage».dao.impl;

import «pkgPackage».dao.*;
import «pkgPackage».dto.*;
import «pkgPackage».qbe.*;
import «pkgPackage».metadata.*;
import «pkgPackage».exceptions.*;
import «getDALayerBasePkg(model)».util.*;
import «getDALayerBasePkg(model)».qbe.*;
import java.util.*;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.ParameterizedRowMapper;
import it.csi.util.performance.StopWatch;
import org.apache.log4j.Logger;
import java.util.Map;
import java.util.TreeMap;


«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(getDaoImplFQN(this,model)+"extraimport")»
// aggiungere qui eventuali import custom. 
«ENDPROTECT»

/**
 * @generated
 */
public class «getDaoImplClassName()» extends AbstractDAO implements ParameterizedRowMapper<«getDtoClassName()»>, «getDaoClassName()»
{
	protected static Logger log = Logger.getLogger(Constants.APPLICATION_CODE);
	/**
	 * @generated
	 */
	protected NamedParameterJdbcTemplate jdbcTemplate;
	
	/**
	 * @generated
	 */
	public void setJdbcTemplate(NamedParameterJdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	«IF inserter != null-»
		«EXPAND insertMethod(model, true) FOR this»
	«ENDIF»
	
	«EXPAND template::datagen::dao::updaters::updaters(model, true) FOR this»
	
	«EXPAND template::datagen::dao::deleters::deleters(model, true) FOR this»
	
	«EXPAND mapRowMethods(model, true) FOR this»

	«IF finders!=null-»
    	«EXPAND rowMapperObject(this) FOREACH this.finders.finders»
    «ENDIF-»

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 * @generated
	 */
	public String getTableName()
	{
		return "«mainTable.name»";
	}

	«EXPAND template::datagen::dao::finders::finders(model, true) FOR this»
	
	«EXPAND rowMapperInnerClass FOR this»
}

«ENDFILE-»
«ENDLET-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR Finder-»
«ERROR "rowMapperObject: tipo di finder non gestito:"+this»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR FindAll-»
	«EXPAND rowMapperObject_internal(dao, this.distinct) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR FindByPK-»
	«EXPAND rowMapperObject_internal(dao, null) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR CustomFinder-»
	«EXPAND rowMapperObject_internal(dao, this.distinct) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject(DataAccessObject dao) FOR QBEFinder-»
	«EXPAND rowMapperObject_internal(dao, this.distinct) FOR this-»
«ENDDEFINE»

«DEFINE rowMapperObject_internal(DataAccessObject dao, List[Column] distinctColumns) FOR Finder-»
	protected «getDaoClassName(dao)»RowMapper «name»RowMapper = new «getDaoClassName(dao)»RowMapper(
	«IF distinctColumns == null || distinctColumns.size==0-»null
	«ELSE-»new String[]{«FOREACH distinctColumns AS currCol SEPARATOR ","»"«currCol.name»"«ENDFOREACH»}
	«ENDIF-»
	);
«ENDDEFINE»


«DEFINE rowMapperInnerClass FOR DataAccessObject»
	/// flexible row mapper. 
	public class «getDaoClassName()»RowMapper implements org.springframework.jdbc.core.RowMapper {
		
		private java.util.HashMap<String,String> columnsToReadMap = new java.util.HashMap<String, String>();
		private boolean mapAllColumns = true;
		
		/**
		 * @param columnsToRead elenco delle colonne da includere nel mapping (per query
		 *        incomplete, esempio distinct, custom select...)
		 */
		public «getDaoClassName()»RowMapper(String[] columnsToRead) {
			if (columnsToRead != null) {
				mapAllColumns = false;
				for (int i=0; i<columnsToRead.length; i++)
					columnsToReadMap.put(columnsToRead[i], columnsToRead[i]);
			}
		}
		
		/**
		 * Method 'mapRow'
		 * 
		 * @param rs
		 * @param row
		 * @throws SQLException
		 * @return «getDtoClassName()»
		 * @generated
		 */
		public «getDtoClassName()» mapRow(ResultSet rs, int row) throws SQLException
		{
			«getDtoClassName()» dto = new «getDtoClassName()»();
			dto = mapRow_internal(dto, rs, row);
			return dto;
		}
			
		/**
		 * Method 'mapRow_internal'
		 * 
		 * @param rs
		 * @param row
		 * @throws SQLException
		 * @return «getDtoClassName()»
		 * @generated
		 */
		public «getDtoClassName()» mapRow_internal(
			«getDtoClassName()» objectToFill, 
			ResultSet rs, 
			int row) throws SQLException
		
		{	
			«getDtoClassName()» dto = objectToFill;
			«FOREACH mainTable.columns AS currCol ITERATOR i»
			if (mapAllColumns || columnsToReadMap.get("«currCol.name»") != null)
				dto.set«javaPropertyNameFromColumn(currCol).toFirstUpper()»(
			«IF !isBlobOrClob(currCol)-»
				«getValueFromRSByColName(currCol)»
			«ELSE-»
				«getValueFromRS(currCol, i.counter1)»
			«ENDIF-»			
				);
			«ENDFOREACH»
			return dto;
		}
		
	}
«ENDDEFINE»

«DEFINE columnNameList(boolean useDistinct) FOR List[TableColumn]-»
«IF useDistinct-»DISTINCT «ENDIF-»«FOREACH this AS currCol SEPARATOR ","-»«((TableColumn)currCol).name-»«ENDFOREACH-»
«ENDDEFINE»

«DEFINE distinctColumnsIfNecessary FOR List[TableColumn]-»
«IF this!=null && !this.isEmpty-»new String[]{«FOREACH this AS currCol SEPARATOR ","-»"«((TableColumn)currCol).name-»"«ENDFOREACH-»}«ENDIF-»
«ENDDEFINE»


«DEFINE columnNameList FOR List[TableColumn]-»
	«EXPAND columnNameList(false) FOR this-»
«ENDDEFINE»

«DEFINE setColumnSetValuePlaceholderList(DataAccessObject dao) FOR List[TableColumn]-»
SET «FOREACH this.select(c|!dao.mainTable.primaryKey.includedColumns.contains(c)) AS currCol SEPARATOR ","-»«((TableColumn)currCol).name» = :«((TableColumn)currCol).name-» «ENDFOREACH-»
«ENDDEFINE»

«DEFINE setColumnEqPlaceholderList(String separator) FOR List[TableColumn]-»
«FOREACH this AS currCol SEPARATOR separator-»«((TableColumn)currCol).name» = :«((TableColumn)currCol).name» «ENDFOREACH-»
«ENDDEFINE»

«DEFINE paramPlaceholderList FOR List[TableColumn]-»
«FOREACH this AS currCol SEPARATOR ","-» :«((TableColumn)currCol).name» «ENDFOREACH-»
«ENDDEFINE»

«DEFINE paramValorizationList(String dtoVarName) FOR List[TableColumn]-»
«FOREACH this AS currCol-»
	params.addValue("«((TableColumn)currCol).name»", «dtoVarName».get«javaPropertyNameFromColumn(currCol).toFirstUpper()»() );	
«ENDFOREACH-»
«ENDDEFINE»

«DEFINE paramValorizationList(String dtoVarName, PKGenerator pkgen) FOR List[TableColumn]-»
«ERROR "valorizzazione parametri non gestita per DAO con PKGenerator di tipo "+pkgen.metaType»
«ENDDEFINE»

«DEFINE paramValorizationList(String dtoVarName, SequencePKGenerator pkgen) FOR List[TableColumn]-»
«LET (DataAccessObject)(pkgen.eContainer) AS dao-»
«LET dao.mainTable.primaryKey.includedColumns.first() AS pkCol-»
«FOREACH this AS currCol-»
	params.addValue("«((TableColumn)currCol).name»", «currCol==pkCol?" newKey ":dtoVarName+".get"+javaPropertyNameFromColumn(currCol).toFirstUpper()+"()"» );
«ENDFOREACH-»
«ENDLET-»
«ENDLET-»
«ENDDEFINE»

«DEFINE orderByClause FOR OrderSpecs»	
  «IF this!=null-»sql.append(" ORDER BY «FOREACH this.specs AS currSpec SEPARATOR ','-»«currSpec.column.name-»«IF currSpec.ascending-» ASC«ELSE-» DESC«ENDIF-»«ENDFOREACH-»");«ENDIF-»		
«ENDDEFINE»


«DEFINE incrementerUse FOR TableColumn-»
«IF type.type == PrimitiveTypeCodes::VARCHAR-»
	«javaPropertyTypeFromColumn()» newKey = incrementer.nextStringValue();
«ELSEIF (isNonDecimalNumber(this.type))-»
	«javaPropertyTypeFromColumn()» newKey = new «javaPropertyTypeFromColumn()»(incrementer.«getIncrementerNextValMethod()»);
«ELSE»
	«ERROR "impossibile usare incrementer per il tipo di colonna "+type.type+","+type.size+","+type.decimalDigits»
«ENDIF-»
		
«ENDDEFINE»

«DEFINE insertMethod(DBAccessModel model, boolean body) FOR DataAccessObject»
	/**
	 * Method 'insert'
	 * 
	 * @param dto
	 * @return «getPkClassName()»
	 * @generated
	 */
	«IF this.mainTable.primaryKey != null»
	public «getPkClassName()» insert(«getDtoClassName()» dto)
	«ELSE»
	public void insert(«getDtoClassName()» dto)
	«ENDIF»	
	«IF body-»
	{
		«IF mainTable.primaryKey!=null && pkGenerator!=null-»
		«EXPAND incrementerUse FOR this.mainTable.primaryKey.includedColumns.first()»
		«ENDIF-»
		final String sql = "INSERT INTO " + getTableName() + " ( «EXPAND columnNameList FOR this.mainTable.columns-» ) VALUES ( «EXPAND paramPlaceholderList FOR this.mainTable.columns-» )";
		
		MapSqlParameterSource params = new MapSqlParameterSource();
		«IF pkGenerator!=null-»
		«EXPAND paramValorizationList("dto",pkGenerator) FOR this.mainTable.columns-»
		«ELSE»
		«EXPAND paramValorizationList("dto") FOR this.mainTable.columns-»
		«ENDIF-»
		StopWatch stopWatch = new StopWatch(Constants.APPLICATION_CODE);
		try {
			stopWatch.start();
			jdbcTemplate.update(sql.toString(), params);
		} catch (RuntimeException ex) {
			log.error("[«getDaoImplClassName()»::insert] esecuzione query",ex);
			throw ex;
		} finally {
			stopWatch.dumpElapsed("«getDaoImplClassName()»", "insert","esecuzione query", sql);
			log.debug("[«getDaoImplClassName()»::insert] END");
		}
		
		«IF this.mainTable.primaryKey != null»
		«IF pkGenerator!=null-»
		«REM»se chiave multipla non funziona!!«ENDREM»
		«EXPAND fillPKFields("dto", "newKey") FOREACH this.mainTable.primaryKey.includedColumns-»
		«ENDIF-»
		return dto.createPk();
		«ENDIF»	
		
	}
	«ELSE-»
	;
	«ENDIF-»
	
«ENDDEFINE»

«DEFINE fillPKFields(String dtoVarName, String keyValVarName) FOR Column»
		«dtoVarName».set«javaPropertyNameFromColumn((TableColumn)this).toFirstUpper()»(«keyValVarName»);
«ENDDEFINE»

«DEFINE mapRowMethods(DBAccessModel model, boolean body) FOR DataAccessObject»
	/**
	 * Method 'mapRow'
	 * 
	 * @param rs
	 * @param row
	 * @throws SQLException
	 * @return «getDtoClassName()»
	 * @generated
	 */
	public «getDtoClassName()» mapRow(ResultSet rs, int row) throws SQLException
	«IF body-»
	{
		«getDtoClassName()» dto = new «getDtoClassName()»();
		dto = mapRow_internal(dto, rs, row);
		return dto;
	}
	«ELSE-»
	;
	«ENDIF-»
	
	
	/**
	 * Method 'mapRow_internal'
	 * 
	 * @param rs
	 * @param row
	 * @throws SQLException
	 * @return «getDtoClassName()»
	 * @generated
	 */
	public «getDtoClassName()» mapRow_internal(
		«getDtoClassName()» objectToFill, 
		ResultSet rs, 
		int row) throws SQLException
	«IF body-»
	{	
		«getDtoClassName()» dto = objectToFill;
		«FOREACH mainTable.columns AS currCol ITERATOR i»
		
		dto.set«javaPropertyNameFromColumn(currCol).toFirstUpper()»(
		«IF !isBlobOrClob(currCol)-»
			«getValueFromRSByColName(currCol)»
		«ELSE-»
			«getValueFromRS(currCol, i.counter1)»
		«ENDIF-»			
			);
		«ENDFOREACH»
		return dto;
	}
	«ELSE-»
	;
	«ENDIF-»
	
	
«ENDDEFINE»


«DEFINE commonDaoFiles(DBAccessModel model) FOR DaoPackage»
«FILE getPkgDir(this, model)+"/dao/impl/AbstractDAO.java"»package «getPkgPackage(this, model)».dao.impl;

import java.io.*;
import java.sql.*;

import org.springframework.jdbc.support.incrementer.DataFieldMaxValueIncrementer;


/**
 * Base class for Oracle DAO classes.
 *
 * @generated
 */
public abstract class AbstractDAO
{
	/**
	 * @generated
	 */
	protected DataFieldMaxValueIncrementer incrementer;
	
	/**
	 * @generated
	 */   
	public void setIncrementer(DataFieldMaxValueIncrementer incrementer) {
		this.incrementer = incrementer;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 * @generated
	 */
	public abstract String getTableName();
	
	
	«EXPAND abstractDAODBMSSpecificCode FOR this»
	
}
«ENDFILE»

«FILE getPkgDir(this, model)+"/exceptions/DaoException.java"»package «getPkgPackage(this, model)».exceptions;

/**
 * @generated
 */
public class DaoException extends RuntimeException
{
	/**
	 * @generated
	 */
	protected Throwable throwable;

	/**
	 * Method 'DaoException'
	 * 
	 * @param message
	 * @generated
	 */
	public DaoException(String message)
	{
		super(message);
	}

	/**
	 * Method 'DaoException'
	 * 
	 * @param message
	 * @param throwable
	 * @generated
	 */
	public DaoException(String message, Throwable throwable)
	{
		super(message);
		this.throwable = throwable;
	}

	/**
	 * Method 'getCause'
	 * 
	 * @return Throwable
	 * @generated
	 */
	public Throwable getCause()
	{
		return throwable;
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE abstractDAODBMSSpecificCode FOR DaoPackage»
«ERROR "abstractDAODBMSSpecificCode: aop non risolta"»
«ENDDEFINE»

«REM»gestire l'univocità della regione protetta per la compatibilità con servicegen«ENDREM»
«DEFINE utilFiles FOR DBAccessModel»
«FILE getDALayerBaseDir(this)+"/util/Constants.java"»package «getDALayerBasePkg(this)».util;
/**
* @generated
*/
public final class Constants {
	/**
	 * identificativo dell'applicativo.
	 */
	public static final String APPLICATION_CODE = "«this.codComponente»";
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("DaoConstants")»
	
	«ENDPROTECT»
}
«ENDFILE»
«ENDDEFINE»

