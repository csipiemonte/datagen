«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT ecore»
«IMPORT datagen»
«IMPORT rdbmdl»
«IMPORT rdbmdl::constraints»
«IMPORT rdbmdl::datatypes»
«IMPORT rdbmdl::view»

«EXTENSION template::DatagenExtensions»

«DEFINE dtoFiles FOR DBAccessModel»
«EXPAND dtoFiles(this) FOREACH daopkgs»
«ENDDEFINE»

«DEFINE dtoFiles (DBAccessModel model) FOR DaoPackage»
«EXPAND dtoFile(model) FOREACH dao»
«REM»creazione del DTO per il custom finder con QDef«ENDREM»
«LET dao.finders.finders.typeSelect(CustomFinder).select(f|f.queryDefinition!=null) AS customJoinFinders»
«EXPAND dtoFileCustomFinderQDef(model) FOREACH customJoinFinders »
«ENDLET»



«EXPAND dtoPkFile(model) FOREACH dao.select(d|d.mainTable.primaryKey != null)»
«ENDDEFINE»

«DEFINE dtoPkFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getPkFullPath(this, model)»package «pkgPackage».dto;

import «pkgPackage».dao.*;
import «pkgPackage».exceptions.*;
import java.io.Serializable;
import java.util.*;

/**
 * @generated
 */
public class «getPkClassName()» implements Serializable {

	«EXPAND columnJavaProperty(this) FOREACH this.mainTable.primaryKey.includedColumns»
	«REM» al momento non gestiamo il caso di FK che e' anche parte di PK nello stesso modo in cui
	facciamo per il dto della tabella che presenta la foreign key 
	«IF this.lookupResolvers!=null»
		«EXPAND lookupResolverProperty FOREACH this.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.select(c|c.isPrimaryKey!=null && c.isPrimaryKey).size > 0)»
	«ENDIF»
	«ENDREM»
	/**
	 * @generated
	 */
	public «getPkClassName()»()
	{
	}

	/**
	 * @generated
	 */
	public «getPkClassName()»(
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol SEPARATOR ","»
		final «javaPropertyTypeFromColumn(currPKCol)» «javaPropertyNameFromColumn(currPKCol)»
		«ENDFOREACH»
	)
	{
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		this._«javaPropertyNameFromColumn(currPKCol)» = «javaPropertyNameFromColumn(currPKCol)»;
		«ENDFOREACH»
	}

	/**
	 * Method 'equals'
	 * 
	 * @param _other
	 * @return boolean
	 */
	public boolean equals(Object _other)
	{
		if (_other == null) {
			return false;
		}
		
		if (_other == this) {
			return true;
		}
		
		if (!(_other instanceof «getPkClassName()»)) {
			return false;
		}
		
		final «getPkClassName()» _cast = («getPkClassName()») _other;
		
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		if (_«javaPropertyNameFromColumn(currPKCol)» == null ? _cast.get«javaPropertyNameFromColumn(currPKCol).toFirstUpper()»() != _«javaPropertyNameFromColumn(currPKCol)» : !_«javaPropertyNameFromColumn(currPKCol)».equals( _cast.get«javaPropertyNameFromColumn(currPKCol).toFirstUpper()»() )) {
			return false;
		}
		«ENDFOREACH»
		
		return true;
	}

	/**
	 * Method 'hashCode'
	 * 
	 * @return int
	 */
	public int hashCode()
	{
		int _hashCode = 0;
		
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		if (_«javaPropertyNameFromColumn(currPKCol)» != null) {
			_hashCode = 29 * _hashCode + _«javaPropertyNameFromColumn(currPKCol)».hashCode();
		}
		«ENDFOREACH»
		
		return _hashCode;
	}

	/**
	 * Method 'toString'
	 * 
	 * @return String
	 */
	public String toString()
	{
		StringBuffer ret = new StringBuffer();
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		ret.append( "«pkgPackage».dto.«getPkClassName()»: " );
		ret.append( "_«javaPropertyNameFromColumn(currPKCol)»=" + _«javaPropertyNameFromColumn(currPKCol)» );
		«ENDFOREACH»
		return ret.toString();
	}
}

«ENDFILE»
«ENDLET»
«ENDDEFINE»

«DEFINE dtoFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDtoFullPath(this, model)»package «pkgPackage».dto;

import «pkgPackage».dao.*;
import «pkgPackage».exceptions.*;
import java.io.Serializable;
import java.util.*;

/**
 * @generated
 */
public class «getDtoClassName()» implements Serializable
{

	«EXPAND columnJavaProperty(this) FOREACH this.mainTable.columns»
	«REM»verificare se non ci sono resolvers«ENDREM»
	«IF this.lookupResolvers!=null && this.lookupResolvers.resolvers.size >0»
		«EXPAND lookupResolverProperty FOREACH this.lookupResolvers.resolvers»
	«ENDIF»
	/**
	 * Method 'equals'
	 * 
	 * @param _other
	 * @return boolean
	 * @generated
	 */
	public boolean equals(Object _other)
	{
		// TODO
		return super.equals(_other);
	}

	/**
	 * Method 'hashCode'
	 * 
	 * @return int
	 * @generated
	 */
	public int hashCode()
	{
		// TODO
		return super.hashCode();
	}

	«IF this.mainTable.primaryKey != null»
		/**
	 * Method 'createPk'
	 * 
	 * @return «getPkClassName()»
	 * @generated
	 */
	public «getPkClassName()» createPk()
	{
		return new «getPkClassName()»(
		«FOREACH this.mainTable.primaryKey.includedColumns AS pkColumn SEPARATOR ","-»
			_«javaPropertyNameFromColumn(pkColumn)»
		«ENDFOREACH-»
		);
	}
	«ENDIF»

	/**
	 * Method 'toString'
	 * 
	 * @return String
	 * @generated
	 */
	public String toString()
	{
		// TODO
		return super.toString();
	}

}


«ENDFILE»
«ENDLET-»
«ENDDEFINE»

«DEFINE columnJavaProperty(DataAccessObject dao) FOR TableColumn-»
	
	
	
	«IF this.isForeignKey!=null && this.isForeignKey && dao.lookupResolvers != null && dao.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.contains(this)).size >0-»
	
	«ELSE-»
	/**
	 * @generated
	 */
	private «javaPropertyTypeFromColumn()» _«javaPropertyNameFromColumn()»;
	
	/**
	 * @generated
	 */
	public void set«javaPropertyNameFromColumn().toFirstUpper()» («javaPropertyTypeFromColumn()» val){
		_«javaPropertyNameFromColumn()» = val;
	}
	
	/**
	 * @generated
	 */
	public «javaPropertyTypeFromColumn()» get«javaPropertyNameFromColumn().toFirstUpper()»(){
		return _«javaPropertyNameFromColumn()»;
	}
	«ENDIF-»
	
	
«ENDDEFINE»


«DEFINE lookupResolverProperty FOR LookupResolver»
/**
	 * @generated
	 */
	private «getDtoClassName(this.supplierDAO)» _«getLookedUpPropertyName()»;
	
	/**
	 * @generated
	 */
	public void set«getLookedUpPropertyName().toFirstUpper()» («getDtoClassName(this.supplierDAO)» val){
		_«getLookedUpPropertyName()» = val;
	}
	
	/**
	 * @generated
	 */
	public «getDtoClassName(this.supplierDAO)» get«getLookedUpPropertyName().toFirstUpper()»(){
		return _«getLookedUpPropertyName()»;
	}

«ENDDEFINE»




«DEFINE dtoFileCustomFinderQDef(DBAccessModel model) FOR CustomFinder»
«LET getPkgPackage((DaoPackage)(this.eContainer.eContainer.eContainer), model) AS pkgPackage-»
«FILE getDtoFullPathQdef((DataAccessObject)this.eContainer.eContainer, model , this)» package «pkgPackage».dto;

import «pkgPackage».dao.*;
import «pkgPackage».exceptions.*;
import java.io.Serializable;
import java.util.*;

/**
 * @generated
 */
public class «getDtoCustomQdefClassName((DataAccessObject)this.eContainer.eContainer,this)»  implements Serializable
{

	«EXPAND columnJavaPropertyQdef FOREACH this.queryDefinition.selectClause.columns.typeSelect(QTableColumn)»
	«EXPAND QCalculatedColumnJavaPropertyQdef FOREACH this.queryDefinition.selectClause.columns.typeSelect(QCalculatedColumn)»
	
	/**
	 * Method 'equals'
	 * 
	 * @param _other
	 * @return boolean
	 * @generated
	 */
	public boolean equals(Object _other)
	{
		// TODO
		return super.equals(_other);
	}

	/**
	 * Method 'hashCode'
	 * 
	 * @return int
	 * @generated
	 */
	public int hashCode()
	{
		// TODO
		return super.hashCode();
	}

	

}
«ENDFILE»
«ENDLET-»
«ENDDEFINE»





«DEFINE columnJavaPropertyQdef FOR QResultColumn»
«ERROR "Non implementato per: "+this»
«ENDDEFINE»

«DEFINE columnJavaPropertyQdef FOR QTableColumn»
	
	«REM»la logica di creazione dei campi del DTO in output: se viene specificato un alias di colonna si provvede a utilizzare tale alias come nome del campo del DTO
	altrimenti, se e' specificato l'alias di tabella si provvede a usarlo come prefisso per il campo del DTO (che avra' quindi il nome della colonna nella clausola 
	di select specificata).Altrimenti si usa direttamente il nome della colonna«ENDREM»
		«IF isNullOrEmpty(this.alias)-»
			«IF isNullOrEmpty(this.qtable.aliasName)-»
			/*	 
			 * @generated
			 */
			private «javaPropertyTypeFromColumn(this.column)» «javaPropertyNameFromColumn(this.column)»;
			
			/**
			 * @generated
			 */
			public void set«javaPropertyNameFromColumn(this.column).toFirstUpper()» («javaPropertyTypeFromColumn(this.column)» val){
				«javaPropertyNameFromColumn(this.column)» = val;
			}
			
			/**
			 * @generated
			 */
			public «javaPropertyTypeFromColumn(this.column)» get«javaPropertyNameFromColumn(this.column).toFirstUpper()»(){
				return «javaPropertyNameFromColumn(this.column)»;
			}
			
			«ELSE»
			/*	 
			 * @generated
			 */
			private «javaPropertyTypeFromColumn(this.column)» «this.qtable.aliasName.toLowerCase()»«javaPropertyNameFromColumn(this.column).toFirstUpper()»;
			
			/**
			 * @generated
			 */
			public void set«this.qtable.aliasName.toFirstUpper()»«javaPropertyNameFromColumn(this.column).toFirstUpper()» («javaPropertyTypeFromColumn(this.column)» val){
				«this.qtable.aliasName.toFirstLower()»«javaPropertyNameFromColumn(this.column).toFirstUpper()» = val;
			}
			/**
			 * @generated
			 */
			public «javaPropertyTypeFromColumn(this.column)» get«this.qtable.aliasName.toFirstUpper()»«javaPropertyNameFromColumn(this.column).toFirstUpper()»(){
				return «this.qtable.aliasName.toLowerCase()»«javaPropertyNameFromColumn(this.column).toFirstUpper()»;
			}
			«ENDIF»
		«ELSE»
			/*	 
			 * @generated
			 */
			private «javaPropertyTypeFromColumn(this.column)» «this.alias.toFirstLower()»;
			
			/**
			 * @generated
			 */
			public void set«this.alias.toFirstUpper()» («javaPropertyTypeFromColumn(this.column)» val){
				«this.alias» = val;
			}
			/**
			 * @generated
			 */
			public «javaPropertyTypeFromColumn(this.column)» get«this.alias.toFirstUpper()»(){
				return «this.alias»;
			}
		«ENDIF»
«ENDDEFINE»


«DEFINE QCalculatedColumnJavaPropertyQdef FOR QCalculatedColumn»
		    
		/**	 
		* @generated
		*/
		private Object «this.alias.toFirstLower()»;
			
		/**
		* @generated
		*/
		public void set«this.alias.toFirstUpper()» (Object val){
		«this.alias» = val;
		}
		/**
		* @generated
		*/
		public Object get«this.alias.toFirstUpper()»(){
			return «this.alias»;
		}
			
«ENDDEFINE»

