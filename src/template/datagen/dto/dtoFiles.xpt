«REM»
C) Copyright 2011 CSI-PIEMONTE;                                             
                                                                            
Concesso in licenza a norma dell'EUPL, esclusivamente versione 1.1;         
Non e' possibile utilizzare l'opera salvo nel rispetto della Licenza.       
E' possibile ottenere una copia della Licenza al seguente indirizzo:        
                                                                            
http://www.eupl.it/opensource/eupl-1-1                                      
                                                                            
Salvo diversamente indicato dalla legge applicabile o concordato per        
iscritto, il software distribuito secondo i termini della Licenza e'        
distribuito "TAL QUALE", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO,         
esplicite o implicite.                                                      
Si veda la Licenza per la lingua specifica che disciplina le autorizzazioni 
e le limitazioni secondo i termini della Licenza.                           
«ENDREM»

«IMPORT ecore»
«IMPORT datagen»
«IMPORT rdbmdl»
«IMPORT rdbmdl::constraints»
«IMPORT rdbmdl::datatypes»
«IMPORT rdbmdl::view»

«EXTENSION template::DatagenExtensions»

«DEFINE dtoFiles FOR DBAccessModel»
«EXPAND dtoFiles(this) FOREACH daopkgs»
«ENDDEFINE»

«DEFINE dtoFiles (DBAccessModel model) FOR DaoPackage»
«EXPAND dtoFile(model) FOREACH dao»
«EXPAND dtoPkFile(model) FOREACH dao.select(d|d.mainTable.primaryKey != null)»
«ENDDEFINE»

«DEFINE dtoPkFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getPkFullPath(this, model)»package «pkgPackage».dto;

import «pkgPackage».dao.*;
import «pkgPackage».exceptions.*;
import java.io.Serializable;
import java.util.*;

/**
 * @generated
 */
public class «getPkClassName()» implements Serializable {

	«EXPAND columnJavaProperty(this) FOREACH this.mainTable.primaryKey.includedColumns»
	«REM» al momento non gestiamo il caso di FK che e' anche parte di PK nello stesso modo in cui
	facciamo per il dto della tabella che presenta la foreign key 
	«IF this.lookupResolvers!=null»
		«EXPAND lookupResolverProperty FOREACH this.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.select(c|c.isPrimaryKey!=null && c.isPrimaryKey).size > 0)»
	«ENDIF»
	«ENDREM»
	/**
	 * @generated
	 */
	public «getPkClassName()»()
	{
	}

	/**
	 * @generated
	 */
	public «getPkClassName()»(
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol SEPARATOR ","»
		final «javaPropertyTypeFromColumn(currPKCol)» «javaPropertyNameFromColumn(currPKCol)»
		«ENDFOREACH»
	)
	{
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		this._«javaPropertyNameFromColumn(currPKCol)» = «javaPropertyNameFromColumn(currPKCol)»;
		«ENDFOREACH»
	}

	/**
	 * Method 'equals'
	 * 
	 * @param _other
	 * @return boolean
	 */
	public boolean equals(Object _other)
	{
		if (_other == null) {
			return false;
		}
		
		if (_other == this) {
			return true;
		}
		
		if (!(_other instanceof «getPkClassName()»)) {
			return false;
		}
		
		final «getPkClassName()» _cast = («getPkClassName()») _other;
		
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		if (_«javaPropertyNameFromColumn(currPKCol)» == null ? _cast.get«javaPropertyNameFromColumn(currPKCol).toFirstUpper()»() != _«javaPropertyNameFromColumn(currPKCol)» : !_«javaPropertyNameFromColumn(currPKCol)».equals( _cast.get«javaPropertyNameFromColumn(currPKCol).toFirstUpper()»() )) {
			return false;
		}
		«ENDFOREACH»
		
		return true;
	}

	/**
	 * Method 'hashCode'
	 * 
	 * @return int
	 */
	public int hashCode()
	{
		int _hashCode = 0;
		
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		if (_«javaPropertyNameFromColumn(currPKCol)» != null) {
			_hashCode = 29 * _hashCode + _«javaPropertyNameFromColumn(currPKCol)».hashCode();
		}
		«ENDFOREACH»
		
		return _hashCode;
	}

	/**
	 * Method 'toString'
	 * 
	 * @return String
	 */
	public String toString()
	{
		StringBuffer ret = new StringBuffer();
		«FOREACH mainTable.primaryKey.includedColumns AS currPKCol»
		ret.append( "«pkgPackage».dto.«getPkClassName()»: " );
		ret.append( "_«javaPropertyNameFromColumn(currPKCol)»=" + _«javaPropertyNameFromColumn(currPKCol)» );
		«ENDFOREACH»
		return ret.toString();
	}
}

«ENDFILE»
«ENDLET»
«ENDDEFINE»

«DEFINE dtoFile(DBAccessModel model) FOR DataAccessObject»
«LET getPkgPackage((DaoPackage)(this.eContainer), model) AS pkgPackage-»
«FILE getDtoFullPath(this, model)»package «pkgPackage».dto;

import «pkgPackage».dao.*;
import «pkgPackage».exceptions.*;
import java.io.Serializable;
import java.util.*;

/**
 * @generated
 */
public class «getDtoClassName()» implements Serializable
{

	«EXPAND columnJavaProperty(this) FOREACH this.mainTable.columns»
	«REM»verificare se non ci sono resolvers«ENDREM»
	«IF this.lookupResolvers!=null && this.lookupResolvers.resolvers.size >0»
		«EXPAND lookupResolverProperty FOREACH this.lookupResolvers.resolvers»
	«ENDIF»
	/**
	 * Method 'equals'
	 * 
	 * @param _other
	 * @return boolean
	 * @generated
	 */
	public boolean equals(Object _other)
	{
		// TODO
		return super.equals(_other);
	}

	/**
	 * Method 'hashCode'
	 * 
	 * @return int
	 * @generated
	 */
	public int hashCode()
	{
		// TODO
		return super.hashCode();
	}

	«IF this.mainTable.primaryKey != null»
		/**
	 * Method 'createPk'
	 * 
	 * @return «getPkClassName()»
	 * @generated
	 */
	public «getPkClassName()» createPk()
	{
		return new «getPkClassName()»(
		«FOREACH this.mainTable.primaryKey.includedColumns AS pkColumn SEPARATOR ","-»
			_«javaPropertyNameFromColumn(pkColumn)»
		«ENDFOREACH-»
		);
	}
	«ENDIF»

	/**
	 * Method 'toString'
	 * 
	 * @return String
	 * @generated
	 */
	public String toString()
	{
		// TODO
		return super.toString();
	}

}


«ENDFILE»
«ENDLET-»
«ENDDEFINE»

«DEFINE columnJavaProperty(DataAccessObject dao) FOR TableColumn-»
	
	
	
	«IF this.isForeignKey!=null && this.isForeignKey && dao.lookupResolvers != null && dao.lookupResolvers.resolvers.select(r|r.foreignKey.includedColumns.contains(this)).size >0-»
	
	«ELSE-»
	/**
	 * @generated
	 */
	private «javaPropertyTypeFromColumn()» _«javaPropertyNameFromColumn()»;
	
	/**
	 * @generated
	 */
	public void set«javaPropertyNameFromColumn().toFirstUpper()» («javaPropertyTypeFromColumn()» val){
		_«javaPropertyNameFromColumn()» = val;
	}
	
	/**
	 * @generated
	 */
	public «javaPropertyTypeFromColumn()» get«javaPropertyNameFromColumn().toFirstUpper()»(){
		return _«javaPropertyNameFromColumn()»;
	}
	«ENDIF-»
	
	
«ENDDEFINE»


«DEFINE lookupResolverProperty FOR LookupResolver»
/**
	 * @generated
	 */
	private «getDtoClassName(this.supplierDAO)» _«getLookedUpPropertyName()»;
	
	/**
	 * @generated
	 */
	public void set«getLookedUpPropertyName().toFirstUpper()» («getDtoClassName(this.supplierDAO)» val){
		_«getLookedUpPropertyName()» = val;
	}
	
	/**
	 * @generated
	 */
	public «getDtoClassName(this.supplierDAO)» get«getLookedUpPropertyName().toFirstUpper()»(){
		return _«getLookedUpPropertyName()»;
	}

«ENDDEFINE»